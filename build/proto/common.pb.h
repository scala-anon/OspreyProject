// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto
// Protobuf C++ Version: 5.26.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_common_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_common_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_common_2eproto;
class Array;
struct ArrayDefaultTypeInternal;
extern ArrayDefaultTypeInternal _Array_default_instance_;
class Attribute;
struct AttributeDefaultTypeInternal;
extern AttributeDefaultTypeInternal _Attribute_default_instance_;
class DataColumn;
struct DataColumnDefaultTypeInternal;
extern DataColumnDefaultTypeInternal _DataColumn_default_instance_;
class DataTimestamps;
struct DataTimestampsDefaultTypeInternal;
extern DataTimestampsDefaultTypeInternal _DataTimestamps_default_instance_;
class DataValue;
struct DataValueDefaultTypeInternal;
extern DataValueDefaultTypeInternal _DataValue_default_instance_;
class DataValue_ValueStatus;
struct DataValue_ValueStatusDefaultTypeInternal;
extern DataValue_ValueStatusDefaultTypeInternal _DataValue_ValueStatus_default_instance_;
class EventMetadata;
struct EventMetadataDefaultTypeInternal;
extern EventMetadataDefaultTypeInternal _EventMetadata_default_instance_;
class ExceptionalResult;
struct ExceptionalResultDefaultTypeInternal;
extern ExceptionalResultDefaultTypeInternal _ExceptionalResult_default_instance_;
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class SamplingClock;
struct SamplingClockDefaultTypeInternal;
extern SamplingClockDefaultTypeInternal _SamplingClock_default_instance_;
class Structure;
struct StructureDefaultTypeInternal;
extern StructureDefaultTypeInternal _Structure_default_instance_;
class Structure_Field;
struct Structure_FieldDefaultTypeInternal;
extern Structure_FieldDefaultTypeInternal _Structure_Field_default_instance_;
class Timestamp;
struct TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class TimestampList;
struct TimestampListDefaultTypeInternal;
extern TimestampListDefaultTypeInternal _TimestampList_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

enum ExceptionalResult_ExceptionalResultStatus : int {
  ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_REJECT = 0,
  ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_ERROR = 1,
  ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_EMPTY = 2,
  ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_NOT_READY = 3,
  ExceptionalResult_ExceptionalResultStatus_ExceptionalResult_ExceptionalResultStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ExceptionalResult_ExceptionalResultStatus_ExceptionalResult_ExceptionalResultStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ExceptionalResult_ExceptionalResultStatus_IsValid(int value);
extern const uint32_t ExceptionalResult_ExceptionalResultStatus_internal_data_[];
constexpr ExceptionalResult_ExceptionalResultStatus ExceptionalResult_ExceptionalResultStatus_ExceptionalResultStatus_MIN = static_cast<ExceptionalResult_ExceptionalResultStatus>(0);
constexpr ExceptionalResult_ExceptionalResultStatus ExceptionalResult_ExceptionalResultStatus_ExceptionalResultStatus_MAX = static_cast<ExceptionalResult_ExceptionalResultStatus>(3);
constexpr int ExceptionalResult_ExceptionalResultStatus_ExceptionalResultStatus_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ExceptionalResult_ExceptionalResultStatus_descriptor();
template <typename T>
const std::string& ExceptionalResult_ExceptionalResultStatus_Name(T value) {
  static_assert(std::is_same<T, ExceptionalResult_ExceptionalResultStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ExceptionalResultStatus_Name().");
  return ExceptionalResult_ExceptionalResultStatus_Name(static_cast<ExceptionalResult_ExceptionalResultStatus>(value));
}
template <>
inline const std::string& ExceptionalResult_ExceptionalResultStatus_Name(ExceptionalResult_ExceptionalResultStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ExceptionalResult_ExceptionalResultStatus_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ExceptionalResult_ExceptionalResultStatus_Parse(absl::string_view name, ExceptionalResult_ExceptionalResultStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExceptionalResult_ExceptionalResultStatus>(
      ExceptionalResult_ExceptionalResultStatus_descriptor(), name, value);
}
enum DataValue_ValueStatus_StatusCode : int {
  DataValue_ValueStatus_StatusCode_NO_STATUS = 0,
  DataValue_ValueStatus_StatusCode_DEVICE_STATUS = 1,
  DataValue_ValueStatus_StatusCode_DRIVER_STATUS = 2,
  DataValue_ValueStatus_StatusCode_RECORD_STATUS = 3,
  DataValue_ValueStatus_StatusCode_DB_STATUS = 4,
  DataValue_ValueStatus_StatusCode_CONF_STATUS = 5,
  DataValue_ValueStatus_StatusCode_UNDEFINED_STATUS = 6,
  DataValue_ValueStatus_StatusCode_CLIENT_STATUS = 7,
  DataValue_ValueStatus_StatusCode_DataValue_ValueStatus_StatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DataValue_ValueStatus_StatusCode_DataValue_ValueStatus_StatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DataValue_ValueStatus_StatusCode_IsValid(int value);
extern const uint32_t DataValue_ValueStatus_StatusCode_internal_data_[];
constexpr DataValue_ValueStatus_StatusCode DataValue_ValueStatus_StatusCode_StatusCode_MIN = static_cast<DataValue_ValueStatus_StatusCode>(0);
constexpr DataValue_ValueStatus_StatusCode DataValue_ValueStatus_StatusCode_StatusCode_MAX = static_cast<DataValue_ValueStatus_StatusCode>(7);
constexpr int DataValue_ValueStatus_StatusCode_StatusCode_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
DataValue_ValueStatus_StatusCode_descriptor();
template <typename T>
const std::string& DataValue_ValueStatus_StatusCode_Name(T value) {
  static_assert(std::is_same<T, DataValue_ValueStatus_StatusCode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StatusCode_Name().");
  return DataValue_ValueStatus_StatusCode_Name(static_cast<DataValue_ValueStatus_StatusCode>(value));
}
template <>
inline const std::string& DataValue_ValueStatus_StatusCode_Name(DataValue_ValueStatus_StatusCode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DataValue_ValueStatus_StatusCode_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool DataValue_ValueStatus_StatusCode_Parse(absl::string_view name, DataValue_ValueStatus_StatusCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataValue_ValueStatus_StatusCode>(
      DataValue_ValueStatus_StatusCode_descriptor(), name, value);
}
enum DataValue_ValueStatus_Severity : int {
  DataValue_ValueStatus_Severity_NO_ALARM = 0,
  DataValue_ValueStatus_Severity_MINOR_ALARM = 1,
  DataValue_ValueStatus_Severity_MAJOR_ALARM = 2,
  DataValue_ValueStatus_Severity_INVALID_ALARM = 3,
  DataValue_ValueStatus_Severity_UNDEFINED_ALARM = 4,
  DataValue_ValueStatus_Severity_DataValue_ValueStatus_Severity_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DataValue_ValueStatus_Severity_DataValue_ValueStatus_Severity_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DataValue_ValueStatus_Severity_IsValid(int value);
extern const uint32_t DataValue_ValueStatus_Severity_internal_data_[];
constexpr DataValue_ValueStatus_Severity DataValue_ValueStatus_Severity_Severity_MIN = static_cast<DataValue_ValueStatus_Severity>(0);
constexpr DataValue_ValueStatus_Severity DataValue_ValueStatus_Severity_Severity_MAX = static_cast<DataValue_ValueStatus_Severity>(4);
constexpr int DataValue_ValueStatus_Severity_Severity_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
DataValue_ValueStatus_Severity_descriptor();
template <typename T>
const std::string& DataValue_ValueStatus_Severity_Name(T value) {
  static_assert(std::is_same<T, DataValue_ValueStatus_Severity>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Severity_Name().");
  return DataValue_ValueStatus_Severity_Name(static_cast<DataValue_ValueStatus_Severity>(value));
}
template <>
inline const std::string& DataValue_ValueStatus_Severity_Name(DataValue_ValueStatus_Severity value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DataValue_ValueStatus_Severity_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool DataValue_ValueStatus_Severity_Parse(absl::string_view name, DataValue_ValueStatus_Severity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataValue_ValueStatus_Severity>(
      DataValue_ValueStatus_Severity_descriptor(), name, value);
}
enum Image_FileType : int {
  Image_FileType_RAW = 0,
  Image_FileType_JPEG = 1,
  Image_FileType_GIF = 2,
  Image_FileType_TIFF = 3,
  Image_FileType_BMP = 4,
  Image_FileType_PNG = 5,
  Image_FileType_EPS = 6,
  Image_FileType_SVG = 7,
  Image_FileType_PDF = 8,
  Image_FileType_Image_FileType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Image_FileType_Image_FileType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Image_FileType_IsValid(int value);
extern const uint32_t Image_FileType_internal_data_[];
constexpr Image_FileType Image_FileType_FileType_MIN = static_cast<Image_FileType>(0);
constexpr Image_FileType Image_FileType_FileType_MAX = static_cast<Image_FileType>(8);
constexpr int Image_FileType_FileType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
Image_FileType_descriptor();
template <typename T>
const std::string& Image_FileType_Name(T value) {
  static_assert(std::is_same<T, Image_FileType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FileType_Name().");
  return Image_FileType_Name(static_cast<Image_FileType>(value));
}
template <>
inline const std::string& Image_FileType_Name(Image_FileType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Image_FileType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool Image_FileType_Parse(absl::string_view name, Image_FileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Image_FileType>(
      Image_FileType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Timestamp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Timestamp) */ {
 public:
  inline Timestamp() : Timestamp(nullptr) {}
  ~Timestamp() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Timestamp(
      ::google::protobuf::internal::ConstantInitialized);

  inline Timestamp(const Timestamp& from) : Timestamp(nullptr, from) {}
  inline Timestamp(Timestamp&& from) noexcept
      : Timestamp(nullptr, std::move(from)) {}
  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Timestamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
        &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Timestamp& a, Timestamp& b) { a.Swap(&b); }
  inline void Swap(Timestamp* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Timestamp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Timestamp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Timestamp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Timestamp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Timestamp& from) { Timestamp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Timestamp* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Timestamp"; }

 protected:
  explicit Timestamp(::google::protobuf::Arena* arena);
  Timestamp(::google::protobuf::Arena* arena, const Timestamp& from);
  Timestamp(::google::protobuf::Arena* arena, Timestamp&& from) noexcept
      : Timestamp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEpochSecondsFieldNumber = 1,
    kNanosecondsFieldNumber = 2,
  };
  // uint64 epochSeconds = 1;
  void clear_epochseconds() ;
  ::uint64_t epochseconds() const;
  void set_epochseconds(::uint64_t value);

  private:
  ::uint64_t _internal_epochseconds() const;
  void _internal_set_epochseconds(::uint64_t value);

  public:
  // uint64 nanoseconds = 2;
  void clear_nanoseconds() ;
  ::uint64_t nanoseconds() const;
  void set_nanoseconds(::uint64_t value);

  private:
  ::uint64_t _internal_nanoseconds() const;
  void _internal_set_nanoseconds(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:Timestamp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t epochseconds_;
    ::uint64_t nanoseconds_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Image final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  ~Image() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Image(
      ::google::protobuf::internal::ConstantInitialized);

  inline Image(const Image& from) : Image(nullptr, from) {}
  inline Image(Image&& from) noexcept
      : Image(nullptr, std::move(from)) {}
  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
        &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(Image& a, Image& b) { a.Swap(&b); }
  inline void Swap(Image* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Image>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Image& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Image& from) { Image::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Image* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Image"; }

 protected:
  explicit Image(::google::protobuf::Arena* arena);
  Image(::google::protobuf::Arena* arena, const Image& from);
  Image(::google::protobuf::Arena* arena, Image&& from) noexcept
      : Image(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using FileType = Image_FileType;
  static constexpr FileType RAW = Image_FileType_RAW;
  static constexpr FileType JPEG = Image_FileType_JPEG;
  static constexpr FileType GIF = Image_FileType_GIF;
  static constexpr FileType TIFF = Image_FileType_TIFF;
  static constexpr FileType BMP = Image_FileType_BMP;
  static constexpr FileType PNG = Image_FileType_PNG;
  static constexpr FileType EPS = Image_FileType_EPS;
  static constexpr FileType SVG = Image_FileType_SVG;
  static constexpr FileType PDF = Image_FileType_PDF;
  static inline bool FileType_IsValid(int value) {
    return Image_FileType_IsValid(value);
  }
  static constexpr FileType FileType_MIN = Image_FileType_FileType_MIN;
  static constexpr FileType FileType_MAX = Image_FileType_FileType_MAX;
  static constexpr int FileType_ARRAYSIZE = Image_FileType_FileType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FileType_descriptor() {
    return Image_FileType_descriptor();
  }
  template <typename T>
  static inline const std::string& FileType_Name(T value) {
    return Image_FileType_Name(value);
  }
  static inline bool FileType_Parse(absl::string_view name, FileType* value) {
    return Image_FileType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kImageFieldNumber = 1,
    kFileTypeFieldNumber = 2,
  };
  // bytes image = 1;
  void clear_image() ;
  const std::string& image() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_image(Arg_&& arg, Args_... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* value);

  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(
      const std::string& value);
  std::string* _internal_mutable_image();

  public:
  // .Image.FileType fileType = 2;
  void clear_filetype() ;
  ::Image_FileType filetype() const;
  void set_filetype(::Image_FileType value);

  private:
  ::Image_FileType _internal_filetype() const;
  void _internal_set_filetype(::Image_FileType value);

  public:
  // @@protoc_insertion_point(class_scope:Image)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr image_;
    int filetype_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ExceptionalResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ExceptionalResult) */ {
 public:
  inline ExceptionalResult() : ExceptionalResult(nullptr) {}
  ~ExceptionalResult() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExceptionalResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExceptionalResult(const ExceptionalResult& from) : ExceptionalResult(nullptr, from) {}
  inline ExceptionalResult(ExceptionalResult&& from) noexcept
      : ExceptionalResult(nullptr, std::move(from)) {}
  inline ExceptionalResult& operator=(const ExceptionalResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExceptionalResult& operator=(ExceptionalResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExceptionalResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExceptionalResult* internal_default_instance() {
    return reinterpret_cast<const ExceptionalResult*>(
        &_ExceptionalResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ExceptionalResult& a, ExceptionalResult& b) { a.Swap(&b); }
  inline void Swap(ExceptionalResult* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExceptionalResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExceptionalResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ExceptionalResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExceptionalResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExceptionalResult& from) { ExceptionalResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExceptionalResult* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ExceptionalResult"; }

 protected:
  explicit ExceptionalResult(::google::protobuf::Arena* arena);
  ExceptionalResult(::google::protobuf::Arena* arena, const ExceptionalResult& from);
  ExceptionalResult(::google::protobuf::Arena* arena, ExceptionalResult&& from) noexcept
      : ExceptionalResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using ExceptionalResultStatus = ExceptionalResult_ExceptionalResultStatus;
  static constexpr ExceptionalResultStatus RESULT_STATUS_REJECT = ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_REJECT;
  static constexpr ExceptionalResultStatus RESULT_STATUS_ERROR = ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_ERROR;
  static constexpr ExceptionalResultStatus RESULT_STATUS_EMPTY = ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_EMPTY;
  static constexpr ExceptionalResultStatus RESULT_STATUS_NOT_READY = ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_NOT_READY;
  static inline bool ExceptionalResultStatus_IsValid(int value) {
    return ExceptionalResult_ExceptionalResultStatus_IsValid(value);
  }
  static constexpr ExceptionalResultStatus ExceptionalResultStatus_MIN = ExceptionalResult_ExceptionalResultStatus_ExceptionalResultStatus_MIN;
  static constexpr ExceptionalResultStatus ExceptionalResultStatus_MAX = ExceptionalResult_ExceptionalResultStatus_ExceptionalResultStatus_MAX;
  static constexpr int ExceptionalResultStatus_ARRAYSIZE = ExceptionalResult_ExceptionalResultStatus_ExceptionalResultStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ExceptionalResultStatus_descriptor() {
    return ExceptionalResult_ExceptionalResultStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& ExceptionalResultStatus_Name(T value) {
    return ExceptionalResult_ExceptionalResultStatus_Name(value);
  }
  static inline bool ExceptionalResultStatus_Parse(absl::string_view name, ExceptionalResultStatus* value) {
    return ExceptionalResult_ExceptionalResultStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kExceptionalResultStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .ExceptionalResult.ExceptionalResultStatus exceptionalResultStatus = 1;
  void clear_exceptionalresultstatus() ;
  ::ExceptionalResult_ExceptionalResultStatus exceptionalresultstatus() const;
  void set_exceptionalresultstatus(::ExceptionalResult_ExceptionalResultStatus value);

  private:
  ::ExceptionalResult_ExceptionalResultStatus _internal_exceptionalresultstatus() const;
  void _internal_set_exceptionalresultstatus(::ExceptionalResult_ExceptionalResultStatus value);

  public:
  // @@protoc_insertion_point(class_scope:ExceptionalResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    int exceptionalresultstatus_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class DataValue_ValueStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DataValue.ValueStatus) */ {
 public:
  inline DataValue_ValueStatus() : DataValue_ValueStatus(nullptr) {}
  ~DataValue_ValueStatus() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DataValue_ValueStatus(
      ::google::protobuf::internal::ConstantInitialized);

  inline DataValue_ValueStatus(const DataValue_ValueStatus& from) : DataValue_ValueStatus(nullptr, from) {}
  inline DataValue_ValueStatus(DataValue_ValueStatus&& from) noexcept
      : DataValue_ValueStatus(nullptr, std::move(from)) {}
  inline DataValue_ValueStatus& operator=(const DataValue_ValueStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataValue_ValueStatus& operator=(DataValue_ValueStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataValue_ValueStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataValue_ValueStatus* internal_default_instance() {
    return reinterpret_cast<const DataValue_ValueStatus*>(
        &_DataValue_ValueStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(DataValue_ValueStatus& a, DataValue_ValueStatus& b) { a.Swap(&b); }
  inline void Swap(DataValue_ValueStatus* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataValue_ValueStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataValue_ValueStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DataValue_ValueStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DataValue_ValueStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DataValue_ValueStatus& from) { DataValue_ValueStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DataValue_ValueStatus* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DataValue.ValueStatus"; }

 protected:
  explicit DataValue_ValueStatus(::google::protobuf::Arena* arena);
  DataValue_ValueStatus(::google::protobuf::Arena* arena, const DataValue_ValueStatus& from);
  DataValue_ValueStatus(::google::protobuf::Arena* arena, DataValue_ValueStatus&& from) noexcept
      : DataValue_ValueStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using StatusCode = DataValue_ValueStatus_StatusCode;
  static constexpr StatusCode NO_STATUS = DataValue_ValueStatus_StatusCode_NO_STATUS;
  static constexpr StatusCode DEVICE_STATUS = DataValue_ValueStatus_StatusCode_DEVICE_STATUS;
  static constexpr StatusCode DRIVER_STATUS = DataValue_ValueStatus_StatusCode_DRIVER_STATUS;
  static constexpr StatusCode RECORD_STATUS = DataValue_ValueStatus_StatusCode_RECORD_STATUS;
  static constexpr StatusCode DB_STATUS = DataValue_ValueStatus_StatusCode_DB_STATUS;
  static constexpr StatusCode CONF_STATUS = DataValue_ValueStatus_StatusCode_CONF_STATUS;
  static constexpr StatusCode UNDEFINED_STATUS = DataValue_ValueStatus_StatusCode_UNDEFINED_STATUS;
  static constexpr StatusCode CLIENT_STATUS = DataValue_ValueStatus_StatusCode_CLIENT_STATUS;
  static inline bool StatusCode_IsValid(int value) {
    return DataValue_ValueStatus_StatusCode_IsValid(value);
  }
  static constexpr StatusCode StatusCode_MIN = DataValue_ValueStatus_StatusCode_StatusCode_MIN;
  static constexpr StatusCode StatusCode_MAX = DataValue_ValueStatus_StatusCode_StatusCode_MAX;
  static constexpr int StatusCode_ARRAYSIZE = DataValue_ValueStatus_StatusCode_StatusCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* StatusCode_descriptor() {
    return DataValue_ValueStatus_StatusCode_descriptor();
  }
  template <typename T>
  static inline const std::string& StatusCode_Name(T value) {
    return DataValue_ValueStatus_StatusCode_Name(value);
  }
  static inline bool StatusCode_Parse(absl::string_view name, StatusCode* value) {
    return DataValue_ValueStatus_StatusCode_Parse(name, value);
  }
  using Severity = DataValue_ValueStatus_Severity;
  static constexpr Severity NO_ALARM = DataValue_ValueStatus_Severity_NO_ALARM;
  static constexpr Severity MINOR_ALARM = DataValue_ValueStatus_Severity_MINOR_ALARM;
  static constexpr Severity MAJOR_ALARM = DataValue_ValueStatus_Severity_MAJOR_ALARM;
  static constexpr Severity INVALID_ALARM = DataValue_ValueStatus_Severity_INVALID_ALARM;
  static constexpr Severity UNDEFINED_ALARM = DataValue_ValueStatus_Severity_UNDEFINED_ALARM;
  static inline bool Severity_IsValid(int value) {
    return DataValue_ValueStatus_Severity_IsValid(value);
  }
  static constexpr Severity Severity_MIN = DataValue_ValueStatus_Severity_Severity_MIN;
  static constexpr Severity Severity_MAX = DataValue_ValueStatus_Severity_Severity_MAX;
  static constexpr int Severity_ARRAYSIZE = DataValue_ValueStatus_Severity_Severity_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Severity_descriptor() {
    return DataValue_ValueStatus_Severity_descriptor();
  }
  template <typename T>
  static inline const std::string& Severity_Name(T value) {
    return DataValue_ValueStatus_Severity_Name(value);
  }
  static inline bool Severity_Parse(absl::string_view name, Severity* value) {
    return DataValue_ValueStatus_Severity_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 1,
    kStatusCodeFieldNumber = 2,
    kSeverityFieldNumber = 3,
  };
  // string message = 1;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .DataValue.ValueStatus.StatusCode statusCode = 2;
  void clear_statuscode() ;
  ::DataValue_ValueStatus_StatusCode statuscode() const;
  void set_statuscode(::DataValue_ValueStatus_StatusCode value);

  private:
  ::DataValue_ValueStatus_StatusCode _internal_statuscode() const;
  void _internal_set_statuscode(::DataValue_ValueStatus_StatusCode value);

  public:
  // .DataValue.ValueStatus.Severity severity = 3;
  void clear_severity() ;
  ::DataValue_ValueStatus_Severity severity() const;
  void set_severity(::DataValue_ValueStatus_Severity value);

  private:
  ::DataValue_ValueStatus_Severity _internal_severity() const;
  void _internal_set_severity(::DataValue_ValueStatus_Severity value);

  public:
  // @@protoc_insertion_point(class_scope:DataValue.ValueStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    int statuscode_;
    int severity_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Attribute final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Attribute) */ {
 public:
  inline Attribute() : Attribute(nullptr) {}
  ~Attribute() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Attribute(
      ::google::protobuf::internal::ConstantInitialized);

  inline Attribute(const Attribute& from) : Attribute(nullptr, from) {}
  inline Attribute(Attribute&& from) noexcept
      : Attribute(nullptr, std::move(from)) {}
  inline Attribute& operator=(const Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline Attribute& operator=(Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Attribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const Attribute* internal_default_instance() {
    return reinterpret_cast<const Attribute*>(
        &_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Attribute& a, Attribute& b) { a.Swap(&b); }
  inline void Swap(Attribute* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Attribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Attribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Attribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Attribute& from) { Attribute::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Attribute* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Attribute"; }

 protected:
  explicit Attribute(::google::protobuf::Arena* arena);
  Attribute(::google::protobuf::Arena* arena, const Attribute& from);
  Attribute(::google::protobuf::Arena* arena, Attribute&& from) noexcept
      : Attribute(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string value = 2;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:Attribute)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      27, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class TimestampList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:TimestampList) */ {
 public:
  inline TimestampList() : TimestampList(nullptr) {}
  ~TimestampList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TimestampList(
      ::google::protobuf::internal::ConstantInitialized);

  inline TimestampList(const TimestampList& from) : TimestampList(nullptr, from) {}
  inline TimestampList(TimestampList&& from) noexcept
      : TimestampList(nullptr, std::move(from)) {}
  inline TimestampList& operator=(const TimestampList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimestampList& operator=(TimestampList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimestampList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimestampList* internal_default_instance() {
    return reinterpret_cast<const TimestampList*>(
        &_TimestampList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(TimestampList& a, TimestampList& b) { a.Swap(&b); }
  inline void Swap(TimestampList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimestampList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimestampList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TimestampList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TimestampList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TimestampList& from) { TimestampList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TimestampList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "TimestampList"; }

 protected:
  explicit TimestampList(::google::protobuf::Arena* arena);
  TimestampList(::google::protobuf::Arena* arena, const TimestampList& from);
  TimestampList(::google::protobuf::Arena* arena, TimestampList&& from) noexcept
      : TimestampList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimestampsFieldNumber = 1,
  };
  // repeated .Timestamp timestamps = 1;
  int timestamps_size() const;
  private:
  int _internal_timestamps_size() const;

  public:
  void clear_timestamps() ;
  ::Timestamp* mutable_timestamps(int index);
  ::google::protobuf::RepeatedPtrField<::Timestamp>* mutable_timestamps();

  private:
  const ::google::protobuf::RepeatedPtrField<::Timestamp>& _internal_timestamps() const;
  ::google::protobuf::RepeatedPtrField<::Timestamp>* _internal_mutable_timestamps();
  public:
  const ::Timestamp& timestamps(int index) const;
  ::Timestamp* add_timestamps();
  const ::google::protobuf::RepeatedPtrField<::Timestamp>& timestamps() const;
  // @@protoc_insertion_point(class_scope:TimestampList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::Timestamp > timestamps_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class SamplingClock final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SamplingClock) */ {
 public:
  inline SamplingClock() : SamplingClock(nullptr) {}
  ~SamplingClock() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SamplingClock(
      ::google::protobuf::internal::ConstantInitialized);

  inline SamplingClock(const SamplingClock& from) : SamplingClock(nullptr, from) {}
  inline SamplingClock(SamplingClock&& from) noexcept
      : SamplingClock(nullptr, std::move(from)) {}
  inline SamplingClock& operator=(const SamplingClock& from) {
    CopyFrom(from);
    return *this;
  }
  inline SamplingClock& operator=(SamplingClock&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SamplingClock& default_instance() {
    return *internal_default_instance();
  }
  static inline const SamplingClock* internal_default_instance() {
    return reinterpret_cast<const SamplingClock*>(
        &_SamplingClock_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(SamplingClock& a, SamplingClock& b) { a.Swap(&b); }
  inline void Swap(SamplingClock* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SamplingClock* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SamplingClock* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SamplingClock>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SamplingClock& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SamplingClock& from) { SamplingClock::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SamplingClock* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SamplingClock"; }

 protected:
  explicit SamplingClock(::google::protobuf::Arena* arena);
  SamplingClock(::google::protobuf::Arena* arena, const SamplingClock& from);
  SamplingClock(::google::protobuf::Arena* arena, SamplingClock&& from) noexcept
      : SamplingClock(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStartTimeFieldNumber = 1,
    kPeriodNanosFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // .Timestamp startTime = 1;
  bool has_starttime() const;
  void clear_starttime() ;
  const ::Timestamp& starttime() const;
  PROTOBUF_NODISCARD ::Timestamp* release_starttime();
  ::Timestamp* mutable_starttime();
  void set_allocated_starttime(::Timestamp* value);
  void unsafe_arena_set_allocated_starttime(::Timestamp* value);
  ::Timestamp* unsafe_arena_release_starttime();

  private:
  const ::Timestamp& _internal_starttime() const;
  ::Timestamp* _internal_mutable_starttime();

  public:
  // uint64 periodNanos = 2;
  void clear_periodnanos() ;
  ::uint64_t periodnanos() const;
  void set_periodnanos(::uint64_t value);

  private:
  ::uint64_t _internal_periodnanos() const;
  void _internal_set_periodnanos(::uint64_t value);

  public:
  // uint32 count = 3;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SamplingClock)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Timestamp* starttime_;
    ::uint64_t periodnanos_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class EventMetadata final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:EventMetadata) */ {
 public:
  inline EventMetadata() : EventMetadata(nullptr) {}
  ~EventMetadata() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EventMetadata(
      ::google::protobuf::internal::ConstantInitialized);

  inline EventMetadata(const EventMetadata& from) : EventMetadata(nullptr, from) {}
  inline EventMetadata(EventMetadata&& from) noexcept
      : EventMetadata(nullptr, std::move(from)) {}
  inline EventMetadata& operator=(const EventMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventMetadata& operator=(EventMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventMetadata* internal_default_instance() {
    return reinterpret_cast<const EventMetadata*>(
        &_EventMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(EventMetadata& a, EventMetadata& b) { a.Swap(&b); }
  inline void Swap(EventMetadata* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventMetadata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<EventMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EventMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EventMetadata& from) { EventMetadata::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EventMetadata* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "EventMetadata"; }

 protected:
  explicit EventMetadata(::google::protobuf::Arena* arena);
  EventMetadata(::google::protobuf::Arena* arena, const EventMetadata& from);
  EventMetadata(::google::protobuf::Arena* arena, EventMetadata&& from) noexcept
      : EventMetadata(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDescriptionFieldNumber = 1,
    kStartTimestampFieldNumber = 2,
    kStopTimestampFieldNumber = 3,
  };
  // string description = 1;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .Timestamp startTimestamp = 2;
  bool has_starttimestamp() const;
  void clear_starttimestamp() ;
  const ::Timestamp& starttimestamp() const;
  PROTOBUF_NODISCARD ::Timestamp* release_starttimestamp();
  ::Timestamp* mutable_starttimestamp();
  void set_allocated_starttimestamp(::Timestamp* value);
  void unsafe_arena_set_allocated_starttimestamp(::Timestamp* value);
  ::Timestamp* unsafe_arena_release_starttimestamp();

  private:
  const ::Timestamp& _internal_starttimestamp() const;
  ::Timestamp* _internal_mutable_starttimestamp();

  public:
  // .Timestamp stopTimestamp = 3;
  bool has_stoptimestamp() const;
  void clear_stoptimestamp() ;
  const ::Timestamp& stoptimestamp() const;
  PROTOBUF_NODISCARD ::Timestamp* release_stoptimestamp();
  ::Timestamp* mutable_stoptimestamp();
  void set_allocated_stoptimestamp(::Timestamp* value);
  void unsafe_arena_set_allocated_stoptimestamp(::Timestamp* value);
  ::Timestamp* unsafe_arena_release_stoptimestamp();

  private:
  const ::Timestamp& _internal_stoptimestamp() const;
  ::Timestamp* _internal_mutable_stoptimestamp();

  public:
  // @@protoc_insertion_point(class_scope:EventMetadata)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::Timestamp* starttimestamp_;
    ::Timestamp* stoptimestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Array final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Array) */ {
 public:
  inline Array() : Array(nullptr) {}
  ~Array() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Array(
      ::google::protobuf::internal::ConstantInitialized);

  inline Array(const Array& from) : Array(nullptr, from) {}
  inline Array(Array&& from) noexcept
      : Array(nullptr, std::move(from)) {}
  inline Array& operator=(const Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Array& operator=(Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Array* internal_default_instance() {
    return reinterpret_cast<const Array*>(
        &_Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(Array& a, Array& b) { a.Swap(&b); }
  inline void Swap(Array* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Array* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Array* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Array>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Array& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Array& from) { Array::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Array* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Array"; }

 protected:
  explicit Array(::google::protobuf::Arena* arena);
  Array(::google::protobuf::Arena* arena, const Array& from);
  Array(::google::protobuf::Arena* arena, Array&& from) noexcept
      : Array(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataValuesFieldNumber = 1,
  };
  // repeated .DataValue dataValues = 1;
  int datavalues_size() const;
  private:
  int _internal_datavalues_size() const;

  public:
  void clear_datavalues() ;
  ::DataValue* mutable_datavalues(int index);
  ::google::protobuf::RepeatedPtrField<::DataValue>* mutable_datavalues();

  private:
  const ::google::protobuf::RepeatedPtrField<::DataValue>& _internal_datavalues() const;
  ::google::protobuf::RepeatedPtrField<::DataValue>* _internal_mutable_datavalues();
  public:
  const ::DataValue& datavalues(int index) const;
  ::DataValue* add_datavalues();
  const ::google::protobuf::RepeatedPtrField<::DataValue>& datavalues() const;
  // @@protoc_insertion_point(class_scope:Array)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::DataValue > datavalues_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class DataValue final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DataValue) */ {
 public:
  inline DataValue() : DataValue(nullptr) {}
  ~DataValue() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DataValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline DataValue(const DataValue& from) : DataValue(nullptr, from) {}
  inline DataValue(DataValue&& from) noexcept
      : DataValue(nullptr, std::move(from)) {}
  inline DataValue& operator=(const DataValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataValue& operator=(DataValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataValue& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kStringValue = 1,
    kBooleanValue = 2,
    kUintValue = 3,
    kUlongValue = 4,
    kIntValue = 5,
    kLongValue = 6,
    kFloatValue = 7,
    kDoubleValue = 8,
    kByteArrayValue = 9,
    kArrayValue = 10,
    kStructureValue = 11,
    kImageValue = 12,
    kTimestampValue = 13,
    VALUE_NOT_SET = 0,
  };
  static inline const DataValue* internal_default_instance() {
    return reinterpret_cast<const DataValue*>(
        &_DataValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(DataValue& a, DataValue& b) { a.Swap(&b); }
  inline void Swap(DataValue* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataValue* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DataValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DataValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DataValue& from) { DataValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DataValue* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DataValue"; }

 protected:
  explicit DataValue(::google::protobuf::Arena* arena);
  DataValue(::google::protobuf::Arena* arena, const DataValue& from);
  DataValue(::google::protobuf::Arena* arena, DataValue&& from) noexcept
      : DataValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using ValueStatus = DataValue_ValueStatus;

  // accessors -------------------------------------------------------
  enum : int {
    kValueStatusFieldNumber = 15,
    kStringValueFieldNumber = 1,
    kBooleanValueFieldNumber = 2,
    kUintValueFieldNumber = 3,
    kUlongValueFieldNumber = 4,
    kIntValueFieldNumber = 5,
    kLongValueFieldNumber = 6,
    kFloatValueFieldNumber = 7,
    kDoubleValueFieldNumber = 8,
    kByteArrayValueFieldNumber = 9,
    kArrayValueFieldNumber = 10,
    kStructureValueFieldNumber = 11,
    kImageValueFieldNumber = 12,
    kTimestampValueFieldNumber = 13,
  };
  // .DataValue.ValueStatus valueStatus = 15;
  bool has_valuestatus() const;
  void clear_valuestatus() ;
  const ::DataValue_ValueStatus& valuestatus() const;
  PROTOBUF_NODISCARD ::DataValue_ValueStatus* release_valuestatus();
  ::DataValue_ValueStatus* mutable_valuestatus();
  void set_allocated_valuestatus(::DataValue_ValueStatus* value);
  void unsafe_arena_set_allocated_valuestatus(::DataValue_ValueStatus* value);
  ::DataValue_ValueStatus* unsafe_arena_release_valuestatus();

  private:
  const ::DataValue_ValueStatus& _internal_valuestatus() const;
  ::DataValue_ValueStatus* _internal_mutable_valuestatus();

  public:
  // string stringValue = 1;
  bool has_stringvalue() const;
  void clear_stringvalue() ;
  const std::string& stringvalue() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stringvalue(Arg_&& arg, Args_... args);
  std::string* mutable_stringvalue();
  PROTOBUF_NODISCARD std::string* release_stringvalue();
  void set_allocated_stringvalue(std::string* value);

  private:
  const std::string& _internal_stringvalue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stringvalue(
      const std::string& value);
  std::string* _internal_mutable_stringvalue();

  public:
  // bool booleanValue = 2;
  bool has_booleanvalue() const;
  void clear_booleanvalue() ;
  bool booleanvalue() const;
  void set_booleanvalue(bool value);

  private:
  bool _internal_booleanvalue() const;
  void _internal_set_booleanvalue(bool value);

  public:
  // uint32 uintValue = 3;
  bool has_uintvalue() const;
  void clear_uintvalue() ;
  ::uint32_t uintvalue() const;
  void set_uintvalue(::uint32_t value);

  private:
  ::uint32_t _internal_uintvalue() const;
  void _internal_set_uintvalue(::uint32_t value);

  public:
  // uint64 ulongValue = 4;
  bool has_ulongvalue() const;
  void clear_ulongvalue() ;
  ::uint64_t ulongvalue() const;
  void set_ulongvalue(::uint64_t value);

  private:
  ::uint64_t _internal_ulongvalue() const;
  void _internal_set_ulongvalue(::uint64_t value);

  public:
  // sint32 intValue = 5;
  bool has_intvalue() const;
  void clear_intvalue() ;
  ::int32_t intvalue() const;
  void set_intvalue(::int32_t value);

  private:
  ::int32_t _internal_intvalue() const;
  void _internal_set_intvalue(::int32_t value);

  public:
  // sint64 longValue = 6;
  bool has_longvalue() const;
  void clear_longvalue() ;
  ::int64_t longvalue() const;
  void set_longvalue(::int64_t value);

  private:
  ::int64_t _internal_longvalue() const;
  void _internal_set_longvalue(::int64_t value);

  public:
  // float floatValue = 7;
  bool has_floatvalue() const;
  void clear_floatvalue() ;
  float floatvalue() const;
  void set_floatvalue(float value);

  private:
  float _internal_floatvalue() const;
  void _internal_set_floatvalue(float value);

  public:
  // double doubleValue = 8;
  bool has_doublevalue() const;
  void clear_doublevalue() ;
  double doublevalue() const;
  void set_doublevalue(double value);

  private:
  double _internal_doublevalue() const;
  void _internal_set_doublevalue(double value);

  public:
  // bytes byteArrayValue = 9;
  bool has_bytearrayvalue() const;
  void clear_bytearrayvalue() ;
  const std::string& bytearrayvalue() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bytearrayvalue(Arg_&& arg, Args_... args);
  std::string* mutable_bytearrayvalue();
  PROTOBUF_NODISCARD std::string* release_bytearrayvalue();
  void set_allocated_bytearrayvalue(std::string* value);

  private:
  const std::string& _internal_bytearrayvalue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bytearrayvalue(
      const std::string& value);
  std::string* _internal_mutable_bytearrayvalue();

  public:
  // .Array arrayValue = 10;
  bool has_arrayvalue() const;
  private:
  bool _internal_has_arrayvalue() const;

  public:
  void clear_arrayvalue() ;
  const ::Array& arrayvalue() const;
  PROTOBUF_NODISCARD ::Array* release_arrayvalue();
  ::Array* mutable_arrayvalue();
  void set_allocated_arrayvalue(::Array* value);
  void unsafe_arena_set_allocated_arrayvalue(::Array* value);
  ::Array* unsafe_arena_release_arrayvalue();

  private:
  const ::Array& _internal_arrayvalue() const;
  ::Array* _internal_mutable_arrayvalue();

  public:
  // .Structure structureValue = 11;
  bool has_structurevalue() const;
  private:
  bool _internal_has_structurevalue() const;

  public:
  void clear_structurevalue() ;
  const ::Structure& structurevalue() const;
  PROTOBUF_NODISCARD ::Structure* release_structurevalue();
  ::Structure* mutable_structurevalue();
  void set_allocated_structurevalue(::Structure* value);
  void unsafe_arena_set_allocated_structurevalue(::Structure* value);
  ::Structure* unsafe_arena_release_structurevalue();

  private:
  const ::Structure& _internal_structurevalue() const;
  ::Structure* _internal_mutable_structurevalue();

  public:
  // .Image imageValue = 12;
  bool has_imagevalue() const;
  private:
  bool _internal_has_imagevalue() const;

  public:
  void clear_imagevalue() ;
  const ::Image& imagevalue() const;
  PROTOBUF_NODISCARD ::Image* release_imagevalue();
  ::Image* mutable_imagevalue();
  void set_allocated_imagevalue(::Image* value);
  void unsafe_arena_set_allocated_imagevalue(::Image* value);
  ::Image* unsafe_arena_release_imagevalue();

  private:
  const ::Image& _internal_imagevalue() const;
  ::Image* _internal_mutable_imagevalue();

  public:
  // .Timestamp timestampValue = 13;
  bool has_timestampvalue() const;
  private:
  bool _internal_has_timestampvalue() const;

  public:
  void clear_timestampvalue() ;
  const ::Timestamp& timestampvalue() const;
  PROTOBUF_NODISCARD ::Timestamp* release_timestampvalue();
  ::Timestamp* mutable_timestampvalue();
  void set_allocated_timestampvalue(::Timestamp* value);
  void unsafe_arena_set_allocated_timestampvalue(::Timestamp* value);
  ::Timestamp* unsafe_arena_release_timestampvalue();

  private:
  const ::Timestamp& _internal_timestampvalue() const;
  ::Timestamp* _internal_mutable_timestampvalue();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:DataValue)
 private:
  class _Internal;
  void set_has_stringvalue();
  void set_has_booleanvalue();
  void set_has_uintvalue();
  void set_has_ulongvalue();
  void set_has_intvalue();
  void set_has_longvalue();
  void set_has_floatvalue();
  void set_has_doublevalue();
  void set_has_bytearrayvalue();
  void set_has_arrayvalue();
  void set_has_structurevalue();
  void set_has_imagevalue();
  void set_has_timestampvalue();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 14, 5,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::DataValue_ValueStatus* valuestatus_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr stringvalue_;
      bool booleanvalue_;
      ::uint32_t uintvalue_;
      ::uint64_t ulongvalue_;
      ::int32_t intvalue_;
      ::int64_t longvalue_;
      float floatvalue_;
      double doublevalue_;
      ::google::protobuf::internal::ArenaStringPtr bytearrayvalue_;
      ::Array* arrayvalue_;
      ::Structure* structurevalue_;
      ::Image* imagevalue_;
      ::Timestamp* timestampvalue_;
    } value_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Structure final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Structure) */ {
 public:
  inline Structure() : Structure(nullptr) {}
  ~Structure() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Structure(
      ::google::protobuf::internal::ConstantInitialized);

  inline Structure(const Structure& from) : Structure(nullptr, from) {}
  inline Structure(Structure&& from) noexcept
      : Structure(nullptr, std::move(from)) {}
  inline Structure& operator=(const Structure& from) {
    CopyFrom(from);
    return *this;
  }
  inline Structure& operator=(Structure&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Structure& default_instance() {
    return *internal_default_instance();
  }
  static inline const Structure* internal_default_instance() {
    return reinterpret_cast<const Structure*>(
        &_Structure_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(Structure& a, Structure& b) { a.Swap(&b); }
  inline void Swap(Structure* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Structure* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Structure* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Structure>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Structure& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Structure& from) { Structure::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Structure* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Structure"; }

 protected:
  explicit Structure(::google::protobuf::Arena* arena);
  Structure(::google::protobuf::Arena* arena, const Structure& from);
  Structure(::google::protobuf::Arena* arena, Structure&& from) noexcept
      : Structure(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using Field = Structure_Field;

  // accessors -------------------------------------------------------
  enum : int {
    kFieldsFieldNumber = 1,
  };
  // repeated .Structure.Field fields = 1;
  int fields_size() const;
  private:
  int _internal_fields_size() const;

  public:
  void clear_fields() ;
  ::Structure_Field* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField<::Structure_Field>* mutable_fields();

  private:
  const ::google::protobuf::RepeatedPtrField<::Structure_Field>& _internal_fields() const;
  ::google::protobuf::RepeatedPtrField<::Structure_Field>* _internal_mutable_fields();
  public:
  const ::Structure_Field& fields(int index) const;
  ::Structure_Field* add_fields();
  const ::google::protobuf::RepeatedPtrField<::Structure_Field>& fields() const;
  // @@protoc_insertion_point(class_scope:Structure)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::Structure_Field > fields_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Structure_Field final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Structure.Field) */ {
 public:
  inline Structure_Field() : Structure_Field(nullptr) {}
  ~Structure_Field() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Structure_Field(
      ::google::protobuf::internal::ConstantInitialized);

  inline Structure_Field(const Structure_Field& from) : Structure_Field(nullptr, from) {}
  inline Structure_Field(Structure_Field&& from) noexcept
      : Structure_Field(nullptr, std::move(from)) {}
  inline Structure_Field& operator=(const Structure_Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline Structure_Field& operator=(Structure_Field&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Structure_Field& default_instance() {
    return *internal_default_instance();
  }
  static inline const Structure_Field* internal_default_instance() {
    return reinterpret_cast<const Structure_Field*>(
        &_Structure_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Structure_Field& a, Structure_Field& b) { a.Swap(&b); }
  inline void Swap(Structure_Field* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Structure_Field* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Structure_Field* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Structure_Field>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Structure_Field& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Structure_Field& from) { Structure_Field::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Structure_Field* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Structure.Field"; }

 protected:
  explicit Structure_Field(::google::protobuf::Arena* arena);
  Structure_Field(::google::protobuf::Arena* arena, const Structure_Field& from);
  Structure_Field(::google::protobuf::Arena* arena, Structure_Field&& from) noexcept
      : Structure_Field(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .DataValue value = 2;
  bool has_value() const;
  void clear_value() ;
  const ::DataValue& value() const;
  PROTOBUF_NODISCARD ::DataValue* release_value();
  ::DataValue* mutable_value();
  void set_allocated_value(::DataValue* value);
  void unsafe_arena_set_allocated_value(::DataValue* value);
  ::DataValue* unsafe_arena_release_value();

  private:
  const ::DataValue& _internal_value() const;
  ::DataValue* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:Structure.Field)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      28, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::DataValue* value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class DataTimestamps final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DataTimestamps) */ {
 public:
  inline DataTimestamps() : DataTimestamps(nullptr) {}
  ~DataTimestamps() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DataTimestamps(
      ::google::protobuf::internal::ConstantInitialized);

  inline DataTimestamps(const DataTimestamps& from) : DataTimestamps(nullptr, from) {}
  inline DataTimestamps(DataTimestamps&& from) noexcept
      : DataTimestamps(nullptr, std::move(from)) {}
  inline DataTimestamps& operator=(const DataTimestamps& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataTimestamps& operator=(DataTimestamps&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataTimestamps& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kSamplingClock = 1,
    kTimestampList = 2,
    VALUE_NOT_SET = 0,
  };
  static inline const DataTimestamps* internal_default_instance() {
    return reinterpret_cast<const DataTimestamps*>(
        &_DataTimestamps_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(DataTimestamps& a, DataTimestamps& b) { a.Swap(&b); }
  inline void Swap(DataTimestamps* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataTimestamps* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataTimestamps* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DataTimestamps>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DataTimestamps& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DataTimestamps& from) { DataTimestamps::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DataTimestamps* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DataTimestamps"; }

 protected:
  explicit DataTimestamps(::google::protobuf::Arena* arena);
  DataTimestamps(::google::protobuf::Arena* arena, const DataTimestamps& from);
  DataTimestamps(::google::protobuf::Arena* arena, DataTimestamps&& from) noexcept
      : DataTimestamps(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSamplingClockFieldNumber = 1,
    kTimestampListFieldNumber = 2,
  };
  // .SamplingClock samplingClock = 1;
  bool has_samplingclock() const;
  private:
  bool _internal_has_samplingclock() const;

  public:
  void clear_samplingclock() ;
  const ::SamplingClock& samplingclock() const;
  PROTOBUF_NODISCARD ::SamplingClock* release_samplingclock();
  ::SamplingClock* mutable_samplingclock();
  void set_allocated_samplingclock(::SamplingClock* value);
  void unsafe_arena_set_allocated_samplingclock(::SamplingClock* value);
  ::SamplingClock* unsafe_arena_release_samplingclock();

  private:
  const ::SamplingClock& _internal_samplingclock() const;
  ::SamplingClock* _internal_mutable_samplingclock();

  public:
  // .TimestampList timestampList = 2;
  bool has_timestamplist() const;
  private:
  bool _internal_has_timestamplist() const;

  public:
  void clear_timestamplist() ;
  const ::TimestampList& timestamplist() const;
  PROTOBUF_NODISCARD ::TimestampList* release_timestamplist();
  ::TimestampList* mutable_timestamplist();
  void set_allocated_timestamplist(::TimestampList* value);
  void unsafe_arena_set_allocated_timestamplist(::TimestampList* value);
  ::TimestampList* unsafe_arena_release_timestamplist();

  private:
  const ::TimestampList& _internal_timestamplist() const;
  ::TimestampList* _internal_mutable_timestamplist();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:DataTimestamps)
 private:
  class _Internal;
  void set_has_samplingclock();
  void set_has_timestamplist();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::SamplingClock* samplingclock_;
      ::TimestampList* timestamplist_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class DataColumn final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DataColumn) */ {
 public:
  inline DataColumn() : DataColumn(nullptr) {}
  ~DataColumn() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DataColumn(
      ::google::protobuf::internal::ConstantInitialized);

  inline DataColumn(const DataColumn& from) : DataColumn(nullptr, from) {}
  inline DataColumn(DataColumn&& from) noexcept
      : DataColumn(nullptr, std::move(from)) {}
  inline DataColumn& operator=(const DataColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataColumn& operator=(DataColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataColumn* internal_default_instance() {
    return reinterpret_cast<const DataColumn*>(
        &_DataColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(DataColumn& a, DataColumn& b) { a.Swap(&b); }
  inline void Swap(DataColumn* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataColumn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataColumn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DataColumn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DataColumn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DataColumn& from) { DataColumn::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DataColumn* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DataColumn"; }

 protected:
  explicit DataColumn(::google::protobuf::Arena* arena);
  DataColumn(::google::protobuf::Arena* arena, const DataColumn& from);
  DataColumn(::google::protobuf::Arena* arena, DataColumn&& from) noexcept
      : DataColumn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataValuesFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .DataValue dataValues = 2;
  int datavalues_size() const;
  private:
  int _internal_datavalues_size() const;

  public:
  void clear_datavalues() ;
  ::DataValue* mutable_datavalues(int index);
  ::google::protobuf::RepeatedPtrField<::DataValue>* mutable_datavalues();

  private:
  const ::google::protobuf::RepeatedPtrField<::DataValue>& _internal_datavalues() const;
  ::google::protobuf::RepeatedPtrField<::DataValue>* _internal_mutable_datavalues();
  public:
  const ::DataValue& datavalues(int index) const;
  ::DataValue* add_datavalues();
  const ::google::protobuf::RepeatedPtrField<::DataValue>& datavalues() const;
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:DataColumn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      23, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::DataValue > datavalues_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Attribute

// string name = 1;
inline void Attribute::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Attribute::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Attribute.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Attribute::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Attribute.name)
}
inline std::string* Attribute::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Attribute.name)
  return _s;
}
inline const std::string& Attribute::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Attribute::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Attribute::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Attribute::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Attribute.name)
  return _impl_.name_.Release();
}
inline void Attribute::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Attribute.name)
}

// string value = 2;
inline void Attribute::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Attribute::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Attribute.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Attribute::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Attribute.value)
}
inline std::string* Attribute::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:Attribute.value)
  return _s;
}
inline const std::string& Attribute::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void Attribute::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.Set(value, GetArena());
}
inline std::string* Attribute::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* Attribute::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Attribute.value)
  return _impl_.value_.Release();
}
inline void Attribute::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Attribute.value)
}

// -------------------------------------------------------------------

// EventMetadata

// string description = 1;
inline void EventMetadata::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& EventMetadata::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:EventMetadata.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventMetadata::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:EventMetadata.description)
}
inline std::string* EventMetadata::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:EventMetadata.description)
  return _s;
}
inline const std::string& EventMetadata::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void EventMetadata::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.Set(value, GetArena());
}
inline std::string* EventMetadata::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* EventMetadata::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:EventMetadata.description)
  return _impl_.description_.Release();
}
inline void EventMetadata::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EventMetadata.description)
}

// .Timestamp startTimestamp = 2;
inline bool EventMetadata::has_starttimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.starttimestamp_ != nullptr);
  return value;
}
inline void EventMetadata::clear_starttimestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.starttimestamp_ != nullptr) _impl_.starttimestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Timestamp& EventMetadata::_internal_starttimestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Timestamp* p = _impl_.starttimestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::Timestamp&>(::_Timestamp_default_instance_);
}
inline const ::Timestamp& EventMetadata::starttimestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:EventMetadata.startTimestamp)
  return _internal_starttimestamp();
}
inline void EventMetadata::unsafe_arena_set_allocated_starttimestamp(::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.starttimestamp_);
  }
  _impl_.starttimestamp_ = reinterpret_cast<::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EventMetadata.startTimestamp)
}
inline ::Timestamp* EventMetadata::release_starttimestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Timestamp* released = _impl_.starttimestamp_;
  _impl_.starttimestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Timestamp* EventMetadata::unsafe_arena_release_starttimestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:EventMetadata.startTimestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Timestamp* temp = _impl_.starttimestamp_;
  _impl_.starttimestamp_ = nullptr;
  return temp;
}
inline ::Timestamp* EventMetadata::_internal_mutable_starttimestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.starttimestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Timestamp>(GetArena());
    _impl_.starttimestamp_ = reinterpret_cast<::Timestamp*>(p);
  }
  return _impl_.starttimestamp_;
}
inline ::Timestamp* EventMetadata::mutable_starttimestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Timestamp* _msg = _internal_mutable_starttimestamp();
  // @@protoc_insertion_point(field_mutable:EventMetadata.startTimestamp)
  return _msg;
}
inline void EventMetadata::set_allocated_starttimestamp(::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.starttimestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.starttimestamp_ = reinterpret_cast<::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:EventMetadata.startTimestamp)
}

// .Timestamp stopTimestamp = 3;
inline bool EventMetadata::has_stoptimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stoptimestamp_ != nullptr);
  return value;
}
inline void EventMetadata::clear_stoptimestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.stoptimestamp_ != nullptr) _impl_.stoptimestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Timestamp& EventMetadata::_internal_stoptimestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Timestamp* p = _impl_.stoptimestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::Timestamp&>(::_Timestamp_default_instance_);
}
inline const ::Timestamp& EventMetadata::stoptimestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:EventMetadata.stopTimestamp)
  return _internal_stoptimestamp();
}
inline void EventMetadata::unsafe_arena_set_allocated_stoptimestamp(::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stoptimestamp_);
  }
  _impl_.stoptimestamp_ = reinterpret_cast<::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EventMetadata.stopTimestamp)
}
inline ::Timestamp* EventMetadata::release_stoptimestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Timestamp* released = _impl_.stoptimestamp_;
  _impl_.stoptimestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Timestamp* EventMetadata::unsafe_arena_release_stoptimestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:EventMetadata.stopTimestamp)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Timestamp* temp = _impl_.stoptimestamp_;
  _impl_.stoptimestamp_ = nullptr;
  return temp;
}
inline ::Timestamp* EventMetadata::_internal_mutable_stoptimestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.stoptimestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Timestamp>(GetArena());
    _impl_.stoptimestamp_ = reinterpret_cast<::Timestamp*>(p);
  }
  return _impl_.stoptimestamp_;
}
inline ::Timestamp* EventMetadata::mutable_stoptimestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::Timestamp* _msg = _internal_mutable_stoptimestamp();
  // @@protoc_insertion_point(field_mutable:EventMetadata.stopTimestamp)
  return _msg;
}
inline void EventMetadata::set_allocated_stoptimestamp(::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.stoptimestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.stoptimestamp_ = reinterpret_cast<::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:EventMetadata.stopTimestamp)
}

// -------------------------------------------------------------------

// Timestamp

// uint64 epochSeconds = 1;
inline void Timestamp::clear_epochseconds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.epochseconds_ = ::uint64_t{0u};
}
inline ::uint64_t Timestamp::epochseconds() const {
  // @@protoc_insertion_point(field_get:Timestamp.epochSeconds)
  return _internal_epochseconds();
}
inline void Timestamp::set_epochseconds(::uint64_t value) {
  _internal_set_epochseconds(value);
  // @@protoc_insertion_point(field_set:Timestamp.epochSeconds)
}
inline ::uint64_t Timestamp::_internal_epochseconds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.epochseconds_;
}
inline void Timestamp::_internal_set_epochseconds(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.epochseconds_ = value;
}

// uint64 nanoseconds = 2;
inline void Timestamp::clear_nanoseconds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nanoseconds_ = ::uint64_t{0u};
}
inline ::uint64_t Timestamp::nanoseconds() const {
  // @@protoc_insertion_point(field_get:Timestamp.nanoseconds)
  return _internal_nanoseconds();
}
inline void Timestamp::set_nanoseconds(::uint64_t value) {
  _internal_set_nanoseconds(value);
  // @@protoc_insertion_point(field_set:Timestamp.nanoseconds)
}
inline ::uint64_t Timestamp::_internal_nanoseconds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nanoseconds_;
}
inline void Timestamp::_internal_set_nanoseconds(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nanoseconds_ = value;
}

// -------------------------------------------------------------------

// TimestampList

// repeated .Timestamp timestamps = 1;
inline int TimestampList::_internal_timestamps_size() const {
  return _internal_timestamps().size();
}
inline int TimestampList::timestamps_size() const {
  return _internal_timestamps_size();
}
inline void TimestampList::clear_timestamps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamps_.Clear();
}
inline ::Timestamp* TimestampList::mutable_timestamps(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:TimestampList.timestamps)
  return _internal_mutable_timestamps()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Timestamp>* TimestampList::mutable_timestamps()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:TimestampList.timestamps)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_timestamps();
}
inline const ::Timestamp& TimestampList::timestamps(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TimestampList.timestamps)
  return _internal_timestamps().Get(index);
}
inline ::Timestamp* TimestampList::add_timestamps() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Timestamp* _add = _internal_mutable_timestamps()->Add();
  // @@protoc_insertion_point(field_add:TimestampList.timestamps)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Timestamp>& TimestampList::timestamps() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:TimestampList.timestamps)
  return _internal_timestamps();
}
inline const ::google::protobuf::RepeatedPtrField<::Timestamp>&
TimestampList::_internal_timestamps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamps_;
}
inline ::google::protobuf::RepeatedPtrField<::Timestamp>*
TimestampList::_internal_mutable_timestamps() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.timestamps_;
}

// -------------------------------------------------------------------

// SamplingClock

// .Timestamp startTime = 1;
inline bool SamplingClock::has_starttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.starttime_ != nullptr);
  return value;
}
inline void SamplingClock::clear_starttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.starttime_ != nullptr) _impl_.starttime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Timestamp& SamplingClock::_internal_starttime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Timestamp* p = _impl_.starttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::Timestamp&>(::_Timestamp_default_instance_);
}
inline const ::Timestamp& SamplingClock::starttime() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SamplingClock.startTime)
  return _internal_starttime();
}
inline void SamplingClock::unsafe_arena_set_allocated_starttime(::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.starttime_);
  }
  _impl_.starttime_ = reinterpret_cast<::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SamplingClock.startTime)
}
inline ::Timestamp* SamplingClock::release_starttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Timestamp* released = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Timestamp* SamplingClock::unsafe_arena_release_starttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SamplingClock.startTime)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Timestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
  return temp;
}
inline ::Timestamp* SamplingClock::_internal_mutable_starttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.starttime_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Timestamp>(GetArena());
    _impl_.starttime_ = reinterpret_cast<::Timestamp*>(p);
  }
  return _impl_.starttime_;
}
inline ::Timestamp* SamplingClock::mutable_starttime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Timestamp* _msg = _internal_mutable_starttime();
  // @@protoc_insertion_point(field_mutable:SamplingClock.startTime)
  return _msg;
}
inline void SamplingClock::set_allocated_starttime(::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.starttime_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.starttime_ = reinterpret_cast<::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:SamplingClock.startTime)
}

// uint64 periodNanos = 2;
inline void SamplingClock::clear_periodnanos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.periodnanos_ = ::uint64_t{0u};
}
inline ::uint64_t SamplingClock::periodnanos() const {
  // @@protoc_insertion_point(field_get:SamplingClock.periodNanos)
  return _internal_periodnanos();
}
inline void SamplingClock::set_periodnanos(::uint64_t value) {
  _internal_set_periodnanos(value);
  // @@protoc_insertion_point(field_set:SamplingClock.periodNanos)
}
inline ::uint64_t SamplingClock::_internal_periodnanos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.periodnanos_;
}
inline void SamplingClock::_internal_set_periodnanos(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.periodnanos_ = value;
}

// uint32 count = 3;
inline void SamplingClock::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
}
inline ::uint32_t SamplingClock::count() const {
  // @@protoc_insertion_point(field_get:SamplingClock.count)
  return _internal_count();
}
inline void SamplingClock::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SamplingClock.count)
}
inline ::uint32_t SamplingClock::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void SamplingClock::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// DataTimestamps

// .SamplingClock samplingClock = 1;
inline bool DataTimestamps::has_samplingclock() const {
  return value_case() == kSamplingClock;
}
inline bool DataTimestamps::_internal_has_samplingclock() const {
  return value_case() == kSamplingClock;
}
inline void DataTimestamps::set_has_samplingclock() {
  _impl_._oneof_case_[0] = kSamplingClock;
}
inline void DataTimestamps::clear_samplingclock() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSamplingClock) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.samplingclock_;
    }
    clear_has_value();
  }
}
inline ::SamplingClock* DataTimestamps::release_samplingclock() {
  // @@protoc_insertion_point(field_release:DataTimestamps.samplingClock)
  if (value_case() == kSamplingClock) {
    clear_has_value();
    auto* temp = _impl_.value_.samplingclock_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.samplingclock_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SamplingClock& DataTimestamps::_internal_samplingclock() const {
  return value_case() == kSamplingClock ? *_impl_.value_.samplingclock_ : reinterpret_cast<::SamplingClock&>(::_SamplingClock_default_instance_);
}
inline const ::SamplingClock& DataTimestamps::samplingclock() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DataTimestamps.samplingClock)
  return _internal_samplingclock();
}
inline ::SamplingClock* DataTimestamps::unsafe_arena_release_samplingclock() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DataTimestamps.samplingClock)
  if (value_case() == kSamplingClock) {
    clear_has_value();
    auto* temp = _impl_.value_.samplingclock_;
    _impl_.value_.samplingclock_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataTimestamps::unsafe_arena_set_allocated_samplingclock(::SamplingClock* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_samplingclock();
    _impl_.value_.samplingclock_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataTimestamps.samplingClock)
}
inline ::SamplingClock* DataTimestamps::_internal_mutable_samplingclock() {
  if (value_case() != kSamplingClock) {
    clear_value();
    set_has_samplingclock();
    _impl_.value_.samplingclock_ =
        ::google::protobuf::Message::DefaultConstruct<::SamplingClock>(GetArena());
  }
  return _impl_.value_.samplingclock_;
}
inline ::SamplingClock* DataTimestamps::mutable_samplingclock() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SamplingClock* _msg = _internal_mutable_samplingclock();
  // @@protoc_insertion_point(field_mutable:DataTimestamps.samplingClock)
  return _msg;
}

// .TimestampList timestampList = 2;
inline bool DataTimestamps::has_timestamplist() const {
  return value_case() == kTimestampList;
}
inline bool DataTimestamps::_internal_has_timestamplist() const {
  return value_case() == kTimestampList;
}
inline void DataTimestamps::set_has_timestamplist() {
  _impl_._oneof_case_[0] = kTimestampList;
}
inline void DataTimestamps::clear_timestamplist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kTimestampList) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.timestamplist_;
    }
    clear_has_value();
  }
}
inline ::TimestampList* DataTimestamps::release_timestamplist() {
  // @@protoc_insertion_point(field_release:DataTimestamps.timestampList)
  if (value_case() == kTimestampList) {
    clear_has_value();
    auto* temp = _impl_.value_.timestamplist_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.timestamplist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TimestampList& DataTimestamps::_internal_timestamplist() const {
  return value_case() == kTimestampList ? *_impl_.value_.timestamplist_ : reinterpret_cast<::TimestampList&>(::_TimestampList_default_instance_);
}
inline const ::TimestampList& DataTimestamps::timestamplist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DataTimestamps.timestampList)
  return _internal_timestamplist();
}
inline ::TimestampList* DataTimestamps::unsafe_arena_release_timestamplist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DataTimestamps.timestampList)
  if (value_case() == kTimestampList) {
    clear_has_value();
    auto* temp = _impl_.value_.timestamplist_;
    _impl_.value_.timestamplist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataTimestamps::unsafe_arena_set_allocated_timestamplist(::TimestampList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_timestamplist();
    _impl_.value_.timestamplist_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataTimestamps.timestampList)
}
inline ::TimestampList* DataTimestamps::_internal_mutable_timestamplist() {
  if (value_case() != kTimestampList) {
    clear_value();
    set_has_timestamplist();
    _impl_.value_.timestamplist_ =
        ::google::protobuf::Message::DefaultConstruct<::TimestampList>(GetArena());
  }
  return _impl_.value_.timestamplist_;
}
inline ::TimestampList* DataTimestamps::mutable_timestamplist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::TimestampList* _msg = _internal_mutable_timestamplist();
  // @@protoc_insertion_point(field_mutable:DataTimestamps.timestampList)
  return _msg;
}

inline bool DataTimestamps::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void DataTimestamps::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline DataTimestamps::ValueCase DataTimestamps::value_case() const {
  return DataTimestamps::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExceptionalResult

// .ExceptionalResult.ExceptionalResultStatus exceptionalResultStatus = 1;
inline void ExceptionalResult::clear_exceptionalresultstatus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exceptionalresultstatus_ = 0;
}
inline ::ExceptionalResult_ExceptionalResultStatus ExceptionalResult::exceptionalresultstatus() const {
  // @@protoc_insertion_point(field_get:ExceptionalResult.exceptionalResultStatus)
  return _internal_exceptionalresultstatus();
}
inline void ExceptionalResult::set_exceptionalresultstatus(::ExceptionalResult_ExceptionalResultStatus value) {
  _internal_set_exceptionalresultstatus(value);
  // @@protoc_insertion_point(field_set:ExceptionalResult.exceptionalResultStatus)
}
inline ::ExceptionalResult_ExceptionalResultStatus ExceptionalResult::_internal_exceptionalresultstatus() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ExceptionalResult_ExceptionalResultStatus>(_impl_.exceptionalresultstatus_);
}
inline void ExceptionalResult::_internal_set_exceptionalresultstatus(::ExceptionalResult_ExceptionalResultStatus value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exceptionalresultstatus_ = value;
}

// string message = 2;
inline void ExceptionalResult::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ExceptionalResult::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ExceptionalResult.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExceptionalResult::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ExceptionalResult.message)
}
inline std::string* ExceptionalResult::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ExceptionalResult.message)
  return _s;
}
inline const std::string& ExceptionalResult::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void ExceptionalResult::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ExceptionalResult::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ExceptionalResult::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ExceptionalResult.message)
  return _impl_.message_.Release();
}
inline void ExceptionalResult::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ExceptionalResult.message)
}

// -------------------------------------------------------------------

// DataColumn

// string name = 1;
inline void DataColumn::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DataColumn::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DataColumn.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataColumn::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DataColumn.name)
}
inline std::string* DataColumn::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:DataColumn.name)
  return _s;
}
inline const std::string& DataColumn::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void DataColumn::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* DataColumn::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* DataColumn::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DataColumn.name)
  return _impl_.name_.Release();
}
inline void DataColumn::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DataColumn.name)
}

// repeated .DataValue dataValues = 2;
inline int DataColumn::_internal_datavalues_size() const {
  return _internal_datavalues().size();
}
inline int DataColumn::datavalues_size() const {
  return _internal_datavalues_size();
}
inline void DataColumn::clear_datavalues() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.datavalues_.Clear();
}
inline ::DataValue* DataColumn::mutable_datavalues(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DataColumn.dataValues)
  return _internal_mutable_datavalues()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DataValue>* DataColumn::mutable_datavalues()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DataColumn.dataValues)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_datavalues();
}
inline const ::DataValue& DataColumn::datavalues(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DataColumn.dataValues)
  return _internal_datavalues().Get(index);
}
inline ::DataValue* DataColumn::add_datavalues() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DataValue* _add = _internal_mutable_datavalues()->Add();
  // @@protoc_insertion_point(field_add:DataColumn.dataValues)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DataValue>& DataColumn::datavalues() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DataColumn.dataValues)
  return _internal_datavalues();
}
inline const ::google::protobuf::RepeatedPtrField<::DataValue>&
DataColumn::_internal_datavalues() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.datavalues_;
}
inline ::google::protobuf::RepeatedPtrField<::DataValue>*
DataColumn::_internal_mutable_datavalues() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.datavalues_;
}

// -------------------------------------------------------------------

// DataValue_ValueStatus

// string message = 1;
inline void DataValue_ValueStatus::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& DataValue_ValueStatus::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DataValue.ValueStatus.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataValue_ValueStatus::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DataValue.ValueStatus.message)
}
inline std::string* DataValue_ValueStatus::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:DataValue.ValueStatus.message)
  return _s;
}
inline const std::string& DataValue_ValueStatus::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void DataValue_ValueStatus::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* DataValue_ValueStatus::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* DataValue_ValueStatus::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DataValue.ValueStatus.message)
  return _impl_.message_.Release();
}
inline void DataValue_ValueStatus::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DataValue.ValueStatus.message)
}

// .DataValue.ValueStatus.StatusCode statusCode = 2;
inline void DataValue_ValueStatus::clear_statuscode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.statuscode_ = 0;
}
inline ::DataValue_ValueStatus_StatusCode DataValue_ValueStatus::statuscode() const {
  // @@protoc_insertion_point(field_get:DataValue.ValueStatus.statusCode)
  return _internal_statuscode();
}
inline void DataValue_ValueStatus::set_statuscode(::DataValue_ValueStatus_StatusCode value) {
  _internal_set_statuscode(value);
  // @@protoc_insertion_point(field_set:DataValue.ValueStatus.statusCode)
}
inline ::DataValue_ValueStatus_StatusCode DataValue_ValueStatus::_internal_statuscode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::DataValue_ValueStatus_StatusCode>(_impl_.statuscode_);
}
inline void DataValue_ValueStatus::_internal_set_statuscode(::DataValue_ValueStatus_StatusCode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.statuscode_ = value;
}

// .DataValue.ValueStatus.Severity severity = 3;
inline void DataValue_ValueStatus::clear_severity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.severity_ = 0;
}
inline ::DataValue_ValueStatus_Severity DataValue_ValueStatus::severity() const {
  // @@protoc_insertion_point(field_get:DataValue.ValueStatus.severity)
  return _internal_severity();
}
inline void DataValue_ValueStatus::set_severity(::DataValue_ValueStatus_Severity value) {
  _internal_set_severity(value);
  // @@protoc_insertion_point(field_set:DataValue.ValueStatus.severity)
}
inline ::DataValue_ValueStatus_Severity DataValue_ValueStatus::_internal_severity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::DataValue_ValueStatus_Severity>(_impl_.severity_);
}
inline void DataValue_ValueStatus::_internal_set_severity(::DataValue_ValueStatus_Severity value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.severity_ = value;
}

// -------------------------------------------------------------------

// DataValue

// string stringValue = 1;
inline bool DataValue::has_stringvalue() const {
  return value_case() == kStringValue;
}
inline void DataValue::set_has_stringvalue() {
  _impl_._oneof_case_[0] = kStringValue;
}
inline void DataValue::clear_stringvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kStringValue) {
    _impl_.value_.stringvalue_.Destroy();
    clear_has_value();
  }
}
inline const std::string& DataValue::stringvalue() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DataValue.stringValue)
  return _internal_stringvalue();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataValue::set_stringvalue(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kStringValue) {
    clear_value();

    set_has_stringvalue();
    _impl_.value_.stringvalue_.InitDefault();
  }
  _impl_.value_.stringvalue_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DataValue.stringValue)
}
inline std::string* DataValue::mutable_stringvalue() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stringvalue();
  // @@protoc_insertion_point(field_mutable:DataValue.stringValue)
  return _s;
}
inline const std::string& DataValue::_internal_stringvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (value_case() != kStringValue) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.value_.stringvalue_.Get();
}
inline void DataValue::_internal_set_stringvalue(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kStringValue) {
    clear_value();

    set_has_stringvalue();
    _impl_.value_.stringvalue_.InitDefault();
  }
  _impl_.value_.stringvalue_.Set(value, GetArena());
}
inline std::string* DataValue::_internal_mutable_stringvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kStringValue) {
    clear_value();

    set_has_stringvalue();
    _impl_.value_.stringvalue_.InitDefault();
  }
  return _impl_.value_.stringvalue_.Mutable( GetArena());
}
inline std::string* DataValue::release_stringvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DataValue.stringValue)
  if (value_case() != kStringValue) {
    return nullptr;
  }
  clear_has_value();
  return _impl_.value_.stringvalue_.Release();
}
inline void DataValue::set_allocated_stringvalue(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_value()) {
    clear_value();
  }
  if (value != nullptr) {
    set_has_stringvalue();
    _impl_.value_.stringvalue_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:DataValue.stringValue)
}

// bool booleanValue = 2;
inline bool DataValue::has_booleanvalue() const {
  return value_case() == kBooleanValue;
}
inline void DataValue::set_has_booleanvalue() {
  _impl_._oneof_case_[0] = kBooleanValue;
}
inline void DataValue::clear_booleanvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kBooleanValue) {
    _impl_.value_.booleanvalue_ = false;
    clear_has_value();
  }
}
inline bool DataValue::booleanvalue() const {
  // @@protoc_insertion_point(field_get:DataValue.booleanValue)
  return _internal_booleanvalue();
}
inline void DataValue::set_booleanvalue(bool value) {
  if (value_case() != kBooleanValue) {
    clear_value();
    set_has_booleanvalue();
  }
  _impl_.value_.booleanvalue_ = value;
  // @@protoc_insertion_point(field_set:DataValue.booleanValue)
}
inline bool DataValue::_internal_booleanvalue() const {
  if (value_case() == kBooleanValue) {
    return _impl_.value_.booleanvalue_;
  }
  return false;
}

// uint32 uintValue = 3;
inline bool DataValue::has_uintvalue() const {
  return value_case() == kUintValue;
}
inline void DataValue::set_has_uintvalue() {
  _impl_._oneof_case_[0] = kUintValue;
}
inline void DataValue::clear_uintvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUintValue) {
    _impl_.value_.uintvalue_ = 0u;
    clear_has_value();
  }
}
inline ::uint32_t DataValue::uintvalue() const {
  // @@protoc_insertion_point(field_get:DataValue.uintValue)
  return _internal_uintvalue();
}
inline void DataValue::set_uintvalue(::uint32_t value) {
  if (value_case() != kUintValue) {
    clear_value();
    set_has_uintvalue();
  }
  _impl_.value_.uintvalue_ = value;
  // @@protoc_insertion_point(field_set:DataValue.uintValue)
}
inline ::uint32_t DataValue::_internal_uintvalue() const {
  if (value_case() == kUintValue) {
    return _impl_.value_.uintvalue_;
  }
  return 0u;
}

// uint64 ulongValue = 4;
inline bool DataValue::has_ulongvalue() const {
  return value_case() == kUlongValue;
}
inline void DataValue::set_has_ulongvalue() {
  _impl_._oneof_case_[0] = kUlongValue;
}
inline void DataValue::clear_ulongvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUlongValue) {
    _impl_.value_.ulongvalue_ = ::uint64_t{0u};
    clear_has_value();
  }
}
inline ::uint64_t DataValue::ulongvalue() const {
  // @@protoc_insertion_point(field_get:DataValue.ulongValue)
  return _internal_ulongvalue();
}
inline void DataValue::set_ulongvalue(::uint64_t value) {
  if (value_case() != kUlongValue) {
    clear_value();
    set_has_ulongvalue();
  }
  _impl_.value_.ulongvalue_ = value;
  // @@protoc_insertion_point(field_set:DataValue.ulongValue)
}
inline ::uint64_t DataValue::_internal_ulongvalue() const {
  if (value_case() == kUlongValue) {
    return _impl_.value_.ulongvalue_;
  }
  return ::uint64_t{0u};
}

// sint32 intValue = 5;
inline bool DataValue::has_intvalue() const {
  return value_case() == kIntValue;
}
inline void DataValue::set_has_intvalue() {
  _impl_._oneof_case_[0] = kIntValue;
}
inline void DataValue::clear_intvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kIntValue) {
    _impl_.value_.intvalue_ = 0;
    clear_has_value();
  }
}
inline ::int32_t DataValue::intvalue() const {
  // @@protoc_insertion_point(field_get:DataValue.intValue)
  return _internal_intvalue();
}
inline void DataValue::set_intvalue(::int32_t value) {
  if (value_case() != kIntValue) {
    clear_value();
    set_has_intvalue();
  }
  _impl_.value_.intvalue_ = value;
  // @@protoc_insertion_point(field_set:DataValue.intValue)
}
inline ::int32_t DataValue::_internal_intvalue() const {
  if (value_case() == kIntValue) {
    return _impl_.value_.intvalue_;
  }
  return 0;
}

// sint64 longValue = 6;
inline bool DataValue::has_longvalue() const {
  return value_case() == kLongValue;
}
inline void DataValue::set_has_longvalue() {
  _impl_._oneof_case_[0] = kLongValue;
}
inline void DataValue::clear_longvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kLongValue) {
    _impl_.value_.longvalue_ = ::int64_t{0};
    clear_has_value();
  }
}
inline ::int64_t DataValue::longvalue() const {
  // @@protoc_insertion_point(field_get:DataValue.longValue)
  return _internal_longvalue();
}
inline void DataValue::set_longvalue(::int64_t value) {
  if (value_case() != kLongValue) {
    clear_value();
    set_has_longvalue();
  }
  _impl_.value_.longvalue_ = value;
  // @@protoc_insertion_point(field_set:DataValue.longValue)
}
inline ::int64_t DataValue::_internal_longvalue() const {
  if (value_case() == kLongValue) {
    return _impl_.value_.longvalue_;
  }
  return ::int64_t{0};
}

// float floatValue = 7;
inline bool DataValue::has_floatvalue() const {
  return value_case() == kFloatValue;
}
inline void DataValue::set_has_floatvalue() {
  _impl_._oneof_case_[0] = kFloatValue;
}
inline void DataValue::clear_floatvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kFloatValue) {
    _impl_.value_.floatvalue_ = 0;
    clear_has_value();
  }
}
inline float DataValue::floatvalue() const {
  // @@protoc_insertion_point(field_get:DataValue.floatValue)
  return _internal_floatvalue();
}
inline void DataValue::set_floatvalue(float value) {
  if (value_case() != kFloatValue) {
    clear_value();
    set_has_floatvalue();
  }
  _impl_.value_.floatvalue_ = value;
  // @@protoc_insertion_point(field_set:DataValue.floatValue)
}
inline float DataValue::_internal_floatvalue() const {
  if (value_case() == kFloatValue) {
    return _impl_.value_.floatvalue_;
  }
  return 0;
}

// double doubleValue = 8;
inline bool DataValue::has_doublevalue() const {
  return value_case() == kDoubleValue;
}
inline void DataValue::set_has_doublevalue() {
  _impl_._oneof_case_[0] = kDoubleValue;
}
inline void DataValue::clear_doublevalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kDoubleValue) {
    _impl_.value_.doublevalue_ = 0;
    clear_has_value();
  }
}
inline double DataValue::doublevalue() const {
  // @@protoc_insertion_point(field_get:DataValue.doubleValue)
  return _internal_doublevalue();
}
inline void DataValue::set_doublevalue(double value) {
  if (value_case() != kDoubleValue) {
    clear_value();
    set_has_doublevalue();
  }
  _impl_.value_.doublevalue_ = value;
  // @@protoc_insertion_point(field_set:DataValue.doubleValue)
}
inline double DataValue::_internal_doublevalue() const {
  if (value_case() == kDoubleValue) {
    return _impl_.value_.doublevalue_;
  }
  return 0;
}

// bytes byteArrayValue = 9;
inline bool DataValue::has_bytearrayvalue() const {
  return value_case() == kByteArrayValue;
}
inline void DataValue::set_has_bytearrayvalue() {
  _impl_._oneof_case_[0] = kByteArrayValue;
}
inline void DataValue::clear_bytearrayvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kByteArrayValue) {
    _impl_.value_.bytearrayvalue_.Destroy();
    clear_has_value();
  }
}
inline const std::string& DataValue::bytearrayvalue() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DataValue.byteArrayValue)
  return _internal_bytearrayvalue();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataValue::set_bytearrayvalue(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kByteArrayValue) {
    clear_value();

    set_has_bytearrayvalue();
    _impl_.value_.bytearrayvalue_.InitDefault();
  }
  _impl_.value_.bytearrayvalue_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DataValue.byteArrayValue)
}
inline std::string* DataValue::mutable_bytearrayvalue() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bytearrayvalue();
  // @@protoc_insertion_point(field_mutable:DataValue.byteArrayValue)
  return _s;
}
inline const std::string& DataValue::_internal_bytearrayvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (value_case() != kByteArrayValue) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.value_.bytearrayvalue_.Get();
}
inline void DataValue::_internal_set_bytearrayvalue(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kByteArrayValue) {
    clear_value();

    set_has_bytearrayvalue();
    _impl_.value_.bytearrayvalue_.InitDefault();
  }
  _impl_.value_.bytearrayvalue_.Set(value, GetArena());
}
inline std::string* DataValue::_internal_mutable_bytearrayvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kByteArrayValue) {
    clear_value();

    set_has_bytearrayvalue();
    _impl_.value_.bytearrayvalue_.InitDefault();
  }
  return _impl_.value_.bytearrayvalue_.Mutable( GetArena());
}
inline std::string* DataValue::release_bytearrayvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DataValue.byteArrayValue)
  if (value_case() != kByteArrayValue) {
    return nullptr;
  }
  clear_has_value();
  return _impl_.value_.bytearrayvalue_.Release();
}
inline void DataValue::set_allocated_bytearrayvalue(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_value()) {
    clear_value();
  }
  if (value != nullptr) {
    set_has_bytearrayvalue();
    _impl_.value_.bytearrayvalue_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:DataValue.byteArrayValue)
}

// .Array arrayValue = 10;
inline bool DataValue::has_arrayvalue() const {
  return value_case() == kArrayValue;
}
inline bool DataValue::_internal_has_arrayvalue() const {
  return value_case() == kArrayValue;
}
inline void DataValue::set_has_arrayvalue() {
  _impl_._oneof_case_[0] = kArrayValue;
}
inline void DataValue::clear_arrayvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kArrayValue) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.arrayvalue_;
    }
    clear_has_value();
  }
}
inline ::Array* DataValue::release_arrayvalue() {
  // @@protoc_insertion_point(field_release:DataValue.arrayValue)
  if (value_case() == kArrayValue) {
    clear_has_value();
    auto* temp = _impl_.value_.arrayvalue_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.arrayvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Array& DataValue::_internal_arrayvalue() const {
  return value_case() == kArrayValue ? *_impl_.value_.arrayvalue_ : reinterpret_cast<::Array&>(::_Array_default_instance_);
}
inline const ::Array& DataValue::arrayvalue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DataValue.arrayValue)
  return _internal_arrayvalue();
}
inline ::Array* DataValue::unsafe_arena_release_arrayvalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DataValue.arrayValue)
  if (value_case() == kArrayValue) {
    clear_has_value();
    auto* temp = _impl_.value_.arrayvalue_;
    _impl_.value_.arrayvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataValue::unsafe_arena_set_allocated_arrayvalue(::Array* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_arrayvalue();
    _impl_.value_.arrayvalue_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataValue.arrayValue)
}
inline ::Array* DataValue::_internal_mutable_arrayvalue() {
  if (value_case() != kArrayValue) {
    clear_value();
    set_has_arrayvalue();
    _impl_.value_.arrayvalue_ =
        ::google::protobuf::Message::DefaultConstruct<::Array>(GetArena());
  }
  return _impl_.value_.arrayvalue_;
}
inline ::Array* DataValue::mutable_arrayvalue() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Array* _msg = _internal_mutable_arrayvalue();
  // @@protoc_insertion_point(field_mutable:DataValue.arrayValue)
  return _msg;
}

// .Structure structureValue = 11;
inline bool DataValue::has_structurevalue() const {
  return value_case() == kStructureValue;
}
inline bool DataValue::_internal_has_structurevalue() const {
  return value_case() == kStructureValue;
}
inline void DataValue::set_has_structurevalue() {
  _impl_._oneof_case_[0] = kStructureValue;
}
inline void DataValue::clear_structurevalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kStructureValue) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.structurevalue_;
    }
    clear_has_value();
  }
}
inline ::Structure* DataValue::release_structurevalue() {
  // @@protoc_insertion_point(field_release:DataValue.structureValue)
  if (value_case() == kStructureValue) {
    clear_has_value();
    auto* temp = _impl_.value_.structurevalue_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.structurevalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Structure& DataValue::_internal_structurevalue() const {
  return value_case() == kStructureValue ? *_impl_.value_.structurevalue_ : reinterpret_cast<::Structure&>(::_Structure_default_instance_);
}
inline const ::Structure& DataValue::structurevalue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DataValue.structureValue)
  return _internal_structurevalue();
}
inline ::Structure* DataValue::unsafe_arena_release_structurevalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DataValue.structureValue)
  if (value_case() == kStructureValue) {
    clear_has_value();
    auto* temp = _impl_.value_.structurevalue_;
    _impl_.value_.structurevalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataValue::unsafe_arena_set_allocated_structurevalue(::Structure* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_structurevalue();
    _impl_.value_.structurevalue_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataValue.structureValue)
}
inline ::Structure* DataValue::_internal_mutable_structurevalue() {
  if (value_case() != kStructureValue) {
    clear_value();
    set_has_structurevalue();
    _impl_.value_.structurevalue_ =
        ::google::protobuf::Message::DefaultConstruct<::Structure>(GetArena());
  }
  return _impl_.value_.structurevalue_;
}
inline ::Structure* DataValue::mutable_structurevalue() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Structure* _msg = _internal_mutable_structurevalue();
  // @@protoc_insertion_point(field_mutable:DataValue.structureValue)
  return _msg;
}

// .Image imageValue = 12;
inline bool DataValue::has_imagevalue() const {
  return value_case() == kImageValue;
}
inline bool DataValue::_internal_has_imagevalue() const {
  return value_case() == kImageValue;
}
inline void DataValue::set_has_imagevalue() {
  _impl_._oneof_case_[0] = kImageValue;
}
inline void DataValue::clear_imagevalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kImageValue) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.imagevalue_;
    }
    clear_has_value();
  }
}
inline ::Image* DataValue::release_imagevalue() {
  // @@protoc_insertion_point(field_release:DataValue.imageValue)
  if (value_case() == kImageValue) {
    clear_has_value();
    auto* temp = _impl_.value_.imagevalue_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.imagevalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Image& DataValue::_internal_imagevalue() const {
  return value_case() == kImageValue ? *_impl_.value_.imagevalue_ : reinterpret_cast<::Image&>(::_Image_default_instance_);
}
inline const ::Image& DataValue::imagevalue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DataValue.imageValue)
  return _internal_imagevalue();
}
inline ::Image* DataValue::unsafe_arena_release_imagevalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DataValue.imageValue)
  if (value_case() == kImageValue) {
    clear_has_value();
    auto* temp = _impl_.value_.imagevalue_;
    _impl_.value_.imagevalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataValue::unsafe_arena_set_allocated_imagevalue(::Image* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_imagevalue();
    _impl_.value_.imagevalue_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataValue.imageValue)
}
inline ::Image* DataValue::_internal_mutable_imagevalue() {
  if (value_case() != kImageValue) {
    clear_value();
    set_has_imagevalue();
    _impl_.value_.imagevalue_ =
        ::google::protobuf::Message::DefaultConstruct<::Image>(GetArena());
  }
  return _impl_.value_.imagevalue_;
}
inline ::Image* DataValue::mutable_imagevalue() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Image* _msg = _internal_mutable_imagevalue();
  // @@protoc_insertion_point(field_mutable:DataValue.imageValue)
  return _msg;
}

// .Timestamp timestampValue = 13;
inline bool DataValue::has_timestampvalue() const {
  return value_case() == kTimestampValue;
}
inline bool DataValue::_internal_has_timestampvalue() const {
  return value_case() == kTimestampValue;
}
inline void DataValue::set_has_timestampvalue() {
  _impl_._oneof_case_[0] = kTimestampValue;
}
inline void DataValue::clear_timestampvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kTimestampValue) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.timestampvalue_;
    }
    clear_has_value();
  }
}
inline ::Timestamp* DataValue::release_timestampvalue() {
  // @@protoc_insertion_point(field_release:DataValue.timestampValue)
  if (value_case() == kTimestampValue) {
    clear_has_value();
    auto* temp = _impl_.value_.timestampvalue_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.timestampvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Timestamp& DataValue::_internal_timestampvalue() const {
  return value_case() == kTimestampValue ? *_impl_.value_.timestampvalue_ : reinterpret_cast<::Timestamp&>(::_Timestamp_default_instance_);
}
inline const ::Timestamp& DataValue::timestampvalue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DataValue.timestampValue)
  return _internal_timestampvalue();
}
inline ::Timestamp* DataValue::unsafe_arena_release_timestampvalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DataValue.timestampValue)
  if (value_case() == kTimestampValue) {
    clear_has_value();
    auto* temp = _impl_.value_.timestampvalue_;
    _impl_.value_.timestampvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataValue::unsafe_arena_set_allocated_timestampvalue(::Timestamp* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_timestampvalue();
    _impl_.value_.timestampvalue_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataValue.timestampValue)
}
inline ::Timestamp* DataValue::_internal_mutable_timestampvalue() {
  if (value_case() != kTimestampValue) {
    clear_value();
    set_has_timestampvalue();
    _impl_.value_.timestampvalue_ =
        ::google::protobuf::Message::DefaultConstruct<::Timestamp>(GetArena());
  }
  return _impl_.value_.timestampvalue_;
}
inline ::Timestamp* DataValue::mutable_timestampvalue() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Timestamp* _msg = _internal_mutable_timestampvalue();
  // @@protoc_insertion_point(field_mutable:DataValue.timestampValue)
  return _msg;
}

// .DataValue.ValueStatus valueStatus = 15;
inline bool DataValue::has_valuestatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.valuestatus_ != nullptr);
  return value;
}
inline void DataValue::clear_valuestatus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.valuestatus_ != nullptr) _impl_.valuestatus_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DataValue_ValueStatus& DataValue::_internal_valuestatus() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DataValue_ValueStatus* p = _impl_.valuestatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::DataValue_ValueStatus&>(::_DataValue_ValueStatus_default_instance_);
}
inline const ::DataValue_ValueStatus& DataValue::valuestatus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DataValue.valueStatus)
  return _internal_valuestatus();
}
inline void DataValue::unsafe_arena_set_allocated_valuestatus(::DataValue_ValueStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.valuestatus_);
  }
  _impl_.valuestatus_ = reinterpret_cast<::DataValue_ValueStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataValue.valueStatus)
}
inline ::DataValue_ValueStatus* DataValue::release_valuestatus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DataValue_ValueStatus* released = _impl_.valuestatus_;
  _impl_.valuestatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DataValue_ValueStatus* DataValue::unsafe_arena_release_valuestatus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DataValue.valueStatus)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DataValue_ValueStatus* temp = _impl_.valuestatus_;
  _impl_.valuestatus_ = nullptr;
  return temp;
}
inline ::DataValue_ValueStatus* DataValue::_internal_mutable_valuestatus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.valuestatus_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DataValue_ValueStatus>(GetArena());
    _impl_.valuestatus_ = reinterpret_cast<::DataValue_ValueStatus*>(p);
  }
  return _impl_.valuestatus_;
}
inline ::DataValue_ValueStatus* DataValue::mutable_valuestatus() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DataValue_ValueStatus* _msg = _internal_mutable_valuestatus();
  // @@protoc_insertion_point(field_mutable:DataValue.valueStatus)
  return _msg;
}
inline void DataValue::set_allocated_valuestatus(::DataValue_ValueStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.valuestatus_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.valuestatus_ = reinterpret_cast<::DataValue_ValueStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:DataValue.valueStatus)
}

inline bool DataValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void DataValue::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline DataValue::ValueCase DataValue::value_case() const {
  return DataValue::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Structure_Field

// string name = 1;
inline void Structure_Field::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Structure_Field::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Structure.Field.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Structure_Field::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Structure.Field.name)
}
inline std::string* Structure_Field::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Structure.Field.name)
  return _s;
}
inline const std::string& Structure_Field::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Structure_Field::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Structure_Field::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Structure_Field::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Structure.Field.name)
  return _impl_.name_.Release();
}
inline void Structure_Field::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Structure.Field.name)
}

// .DataValue value = 2;
inline bool Structure_Field::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline void Structure_Field::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DataValue& Structure_Field::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DataValue* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::DataValue&>(::_DataValue_default_instance_);
}
inline const ::DataValue& Structure_Field::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Structure.Field.value)
  return _internal_value();
}
inline void Structure_Field::unsafe_arena_set_allocated_value(::DataValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::DataValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Structure.Field.value)
}
inline ::DataValue* Structure_Field::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DataValue* released = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DataValue* Structure_Field::unsafe_arena_release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Structure.Field.value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DataValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::DataValue* Structure_Field::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DataValue>(GetArena());
    _impl_.value_ = reinterpret_cast<::DataValue*>(p);
  }
  return _impl_.value_;
}
inline ::DataValue* Structure_Field::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DataValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:Structure.Field.value)
  return _msg;
}
inline void Structure_Field::set_allocated_value(::DataValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.value_ = reinterpret_cast<::DataValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:Structure.Field.value)
}

// -------------------------------------------------------------------

// Structure

// repeated .Structure.Field fields = 1;
inline int Structure::_internal_fields_size() const {
  return _internal_fields().size();
}
inline int Structure::fields_size() const {
  return _internal_fields_size();
}
inline void Structure::clear_fields() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fields_.Clear();
}
inline ::Structure_Field* Structure::mutable_fields(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:Structure.fields)
  return _internal_mutable_fields()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Structure_Field>* Structure::mutable_fields()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Structure.fields)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_fields();
}
inline const ::Structure_Field& Structure::fields(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Structure.fields)
  return _internal_fields().Get(index);
}
inline ::Structure_Field* Structure::add_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Structure_Field* _add = _internal_mutable_fields()->Add();
  // @@protoc_insertion_point(field_add:Structure.fields)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Structure_Field>& Structure::fields() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Structure.fields)
  return _internal_fields();
}
inline const ::google::protobuf::RepeatedPtrField<::Structure_Field>&
Structure::_internal_fields() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fields_;
}
inline ::google::protobuf::RepeatedPtrField<::Structure_Field>*
Structure::_internal_mutable_fields() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.fields_;
}

// -------------------------------------------------------------------

// Array

// repeated .DataValue dataValues = 1;
inline int Array::_internal_datavalues_size() const {
  return _internal_datavalues().size();
}
inline int Array::datavalues_size() const {
  return _internal_datavalues_size();
}
inline void Array::clear_datavalues() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.datavalues_.Clear();
}
inline ::DataValue* Array::mutable_datavalues(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:Array.dataValues)
  return _internal_mutable_datavalues()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DataValue>* Array::mutable_datavalues()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Array.dataValues)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_datavalues();
}
inline const ::DataValue& Array::datavalues(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Array.dataValues)
  return _internal_datavalues().Get(index);
}
inline ::DataValue* Array::add_datavalues() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DataValue* _add = _internal_mutable_datavalues()->Add();
  // @@protoc_insertion_point(field_add:Array.dataValues)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DataValue>& Array::datavalues() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Array.dataValues)
  return _internal_datavalues();
}
inline const ::google::protobuf::RepeatedPtrField<::DataValue>&
Array::_internal_datavalues() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.datavalues_;
}
inline ::google::protobuf::RepeatedPtrField<::DataValue>*
Array::_internal_mutable_datavalues() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.datavalues_;
}

// -------------------------------------------------------------------

// Image

// bytes image = 1;
inline void Image::clear_image() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.image_.ClearToEmpty();
}
inline const std::string& Image::image() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Image.image)
  return _internal_image();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Image::set_image(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.image_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Image.image)
}
inline std::string* Image::mutable_image() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:Image.image)
  return _s;
}
inline const std::string& Image::_internal_image() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.image_.Get();
}
inline void Image::_internal_set_image(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.image_.Set(value, GetArena());
}
inline std::string* Image::_internal_mutable_image() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.image_.Mutable( GetArena());
}
inline std::string* Image::release_image() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Image.image)
  return _impl_.image_.Release();
}
inline void Image::set_allocated_image(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.image_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.image_.IsDefault()) {
          _impl_.image_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Image.image)
}

// .Image.FileType fileType = 2;
inline void Image::clear_filetype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filetype_ = 0;
}
inline ::Image_FileType Image::filetype() const {
  // @@protoc_insertion_point(field_get:Image.fileType)
  return _internal_filetype();
}
inline void Image::set_filetype(::Image_FileType value) {
  _internal_set_filetype(value);
  // @@protoc_insertion_point(field_set:Image.fileType)
}
inline ::Image_FileType Image::_internal_filetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Image_FileType>(_impl_.filetype_);
}
inline void Image::_internal_set_filetype(::Image_FileType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filetype_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::ExceptionalResult_ExceptionalResultStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ExceptionalResult_ExceptionalResultStatus>() {
  return ::ExceptionalResult_ExceptionalResultStatus_descriptor();
}
template <>
struct is_proto_enum<::DataValue_ValueStatus_StatusCode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DataValue_ValueStatus_StatusCode>() {
  return ::DataValue_ValueStatus_StatusCode_descriptor();
}
template <>
struct is_proto_enum<::DataValue_ValueStatus_Severity> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DataValue_ValueStatus_Severity>() {
  return ::DataValue_ValueStatus_Severity_descriptor();
}
template <>
struct is_proto_enum<::Image_FileType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Image_FileType>() {
  return ::Image_FileType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_common_2eproto_2epb_2eh
